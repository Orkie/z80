;;; CP/M BIOS implementation (needs to fit into 1536 bytes)

include "../lib/hw.z80"
CPM_ROM_LOC:	equ 0x2000
bdos:	equ	0EC06h		;bdos entry
cdisk:		equ 0x0004	; address of current disk number 0=a,... l5=p
iobyte:		equ 0x0003	; intel i/o byte
	
_TODO:
	RET
	
;;; ============================================================================
;;; Cold boot
;;; ============================================================================
_BOOT:
	JP	_WBOOT_SkipRom

;;; ============================================================================
;;; Warm boot - reloads CP/M from ROM
;;;   We store the CP/M binary at 0x2000 in ROM, so switch out LO-RAM,
;;;   calculate difference between CBASE and BOOT labels (i.e. size of CP/M)
;;;   and copy that many bytes to address starting CBASE. Switch back to LO-RAM
;;;   after doing this
;;; ============================================================================
_WBOOT:
	XOR	A
	OUT	(0x80), A	; select lo-rom
	CCF
	LD	HL, BOOT
	LD	DE, CBASE
	SBC	HL, DE		; size of image
	LD	B, H
	LD	C, L
	LD	HL, CPM_ROM_LOC	; source
	LD	DE, CBASE	; destination
	LDIR
_WBOOT_SkipRom:
	XOR	A
	OUT	(0x80), A	; select lo-ram

	XOR	A
	LD	(iobyte), A
	LD	(cdisk), A

	LD 	a, 0c3h		;c3 is a jmp instruction
	LD	(0),A		;for jmp to wboot
	LD	HL, WBOOT	;wboot entry point
	LD	(1),HL		;set address field for jmp at 0
;
	LD	(5),A		;for jmp to bdos
	LD	HL, bdos	;bdos entry point
	LD	(6),HL		;address field of Jump at 5 to bdos
;
	;; LD	BC, 80h		;default dma address is 80h
	;; call	setdma
;
;; 	ei			;enable the interrupt system
;; 	LD	A,(cdisk)	;get current disk number
;; 	cp	disks		;see if valid disk number
;; 	jp	c,diskok	;disk valid, go to ccp
;; 	ld	a,0		;invalid disk, change to disk 0
;; diskok:	LD 	c, a		;send to the ccp
	
	JP	CBASE		; launch CP/M

;;; ============================================================================
;;; Console status
;;; sets A to 0x00 if no character is ready to be read
;;; sets A to 0xFF if a character is ready to be read
;;; ============================================================================
_CONST:
	IN	A, (UART_LSR)
	BIT	5, A
 	JP 	Z, _CONST_NoChar
	LD	A, 0xFF
	RET
_CONST_NoChar:	
	LD	A, 0x00
	RET

;;; ============================================================================
;;; Console in
;;; reads a character and puts it in A (blocking)
;;; ============================================================================
_CONIN:
	IN	A, (UART_LSR)	; Wait for a character to become available in RHR
	BIT	0, A
	JP	Z, _CONIN
	IN	A, (UART_RHR)	; Read from RHR
	RET	

;;; ============================================================================
;;; Console out
;;; writes the character in C
;;; ============================================================================
_CONOUT:
	IN	A, (UART_LSR)
	BIT	5, A
 	JP 	Z, _CONOUT
	LD	A, C
	OUT	(UART_THR), A	
	RET


CF_DPH:
	dw 	0xFFFF		; sectors per track
	db 	7
	db	127

CF_SCRATCH:	 defs 	512
	
