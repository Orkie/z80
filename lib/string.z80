;;; String manipulation routines

;;; ============================================================================
;;; Tests for string equality, Z flag set if they are equal
;;; HL - address of string 1
;;; BC - address of string 2
;;; ============================================================================	
String_Equal:	
	LD	A, (BC)
	CP	(HL)
	RET	NZ
	INC	BC
	INC	HL
	CP	'\0'
	RET	Z
	JP	String_Equal

;;; ============================================================================
;;; Copies the nth word in a string (words separated by spaces)
;;; Will stop copying if \0 is encountered in the source.
;;; HL - source string
;;; DE - destination
;;; B - nth word (0-indexed)
;;; ============================================================================
String_Word:
	PUSH	BC
String_Word_Loop:
	LD	C, (HL)		; Get the next character from source string
	INC	HL
	LD	A, ' '		; If we have read a space, skip to next word
	CP	C
	JP	Z, String_Word_NextWord
	LD	A, 0		; If B != 0, this isn't our word so dont copy it
	CP	B
	LD	A, C		
	JP	NZ, String_Word_SkipCopy
	LD	(DE), A ; Copy character 
	INC	DE
String_Word_SkipCopy:
	CP	'\0'		; If the character was NULL, we're done
	JP	Z, String_Word_Return
	JP	String_Word_Loop ; Otherwise, keep going
String_Word_NextWord:
	LD	A, 0
	CP	B
	JP	Z, String_Word_Finalise ; If B is 0, we're done
	DEC	B
	JP	String_Word_Loop
String_Word_Finalise:
	LD	A, 0x00		; Add null termination to destination string
	LD	(DE), A
String_Word_Return:	
	POP	BC
	RET
	
;;; ============================================================================
;;; Converts a byte to ASCII
;;; A - byte to convert
;;; H - first nibble of byte in ASCII (MSB)
;;; L - first nibble of byte in ASCII (LSB)
;;; ============================================================================	
String_ByteToAscii:
	PUSH	BC
	LD	B, A
	CALL	String_NibbleToAscii ; Convert LSB
	LD	L, A
	LD	A, B		; Convert MSB
	SRA	A
	SRA	A
	SRA	A
	SRA	A
	CALL	String_NibbleToAscii
	LD	H, A	
	POP	BC
	RET

;;; ============================================================================
;;; Converts a byte to ASCII
;;; A - nibble to convert
;;; A - set to ASCII value for nibble
;;; ============================================================================	
String_NibbleToAscii:
	AND	0x0F
	CP	10
	JP	C, String_NibbleToAscii_IsNumber
	ADD 	A, 0x37
	RET
String_NibbleToAscii_IsNumber:
	ADD 	A, 0x30
	RET

;;; ============================================================================
;;; Upper cases all letters in a string
;;; HL - address of string to make upper case
;;; ============================================================================
String_ToUpper:
	LD	A, (HL)
	CP	'\0'		; If we've hit end of string, we're done
	RET	Z
	CP	0x61		; If the value is < 'a', no need to do anything
	JP	C, String_ToUpper_Next
	CP	0x7B		; If the value >= '{', no need to do anything
	JP	NC, String_ToUpper_Next
	SUB	0x20		; Modify character
	LD	(HL), A
String_ToUpper_Next:
	INC	HL
	JP 	String_ToUpper
	
	
